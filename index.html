<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Study Visualizer — Interactive 3D Cube</title>
  <style>
    /* (kept your rich CSS) */
    :root{--accent:#ff6b9d;--accent-2:#c44569;--accent-3:#feca57;--accent-4:#48dbfb;--accent-5:#ff9ff3;--bg:#1a0033;--card:#2d0066;--muted:#d4a5ff}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(135deg,#667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);background-size:400% 400%;animation:gradientShift 15s ease infinite;color:#fff}
    @keyframes gradientShift{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
    .wrap{max-width:1200px;margin:28px auto;padding:20px}
    header{display:flex;align-items:center;gap:18px}
    .logo{width:56px;height:56px;border-radius:16px;background:linear-gradient(135deg,#ff6b9d,#feca57,#48dbfb);display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;box-shadow:0 12px 40px rgba(255,107,157,0.6),0 0 60px rgba(254,202,87,0.4);animation:logoFloat 3s ease-in-out infinite}
    h1{margin:0;font-size:26px;background:linear-gradient(135deg,#fff,#feca57,#ff6b9d);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:titleShimmer 3s ease-in-out infinite}
    @keyframes titleShimmer{0%,100%{filter:hue-rotate(0deg)}50%{filter:hue-rotate(20deg)}}
    @keyframes logoFloat{0%,100%{transform:translateY(0px) rotate(0deg)}50%{transform:translateY(-10px) rotate(5deg)}}
    p.lead{margin:4px 0 0;color:#fff;text-shadow:0 2px 4px rgba(0,0,0,0.3)}
    main{display:grid;grid-template-columns:1fr 420px;gap:20px;margin-top:18px}
    .card{background:linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));backdrop-filter:blur(20px);border-radius:20px;padding:16px;box-shadow:0 8px 32px rgba(31,38,135,0.37),0 0 80px rgba(255,107,157,0.2);border:1px solid rgba(255,255,255,0.18)}
    .hero{display:flex;gap:16px;align-items:center}
    .hero .left{flex:1}
    .hero .controls{display:flex;gap:8px;margin-top:12px}
    .btn{background:linear-gradient(135deg,#ff6b9d,#feca57);color:#fff;padding:10px 20px;border-radius:12px;border:0;cursor:pointer;font-weight:700;box-shadow:0 4px 15px rgba(255,107,157,0.4);transition:all 0.3s ease;text-shadow:0 2px 4px rgba(0,0,0,0.2)}
    .btn:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(255,107,157,0.6)}
    .btn-ghost{background:rgba(255,255,255,0.1);backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.3);color:#fff;padding:8px 16px;border-radius:12px;cursor:pointer;transition:all 0.3s ease;font-weight:600}
    .btn-ghost:hover{background:rgba(255,255,255,0.2);border-color:rgba(255,255,255,0.5);transform:translateY(-2px)}
    .stage{width:100%;height:420px;display:flex;align-items:center;justify-content:center;perspective:1600px;position:relative}
    .scene{width:360px;height:360px;position:relative;transform-style:preserve-3d;transition:transform 350ms cubic-bezier(.2,.9,.3,1)}
    .cube-face{position:absolute;width:360px;height:360px;left:0;top:0;border-radius:16px;overflow:hidden;backface-visibility:hidden;display:flex;align-items:center;justify-content:center;background:#fff;box-shadow:0 0 40px rgba(255,107,157,0.6),inset 0 0 20px rgba(254,202,87,0.3)}
    .cube-face img{width:100%;height:100%;object-fit:cover;display:block}
    .face-front{transform:translateZ(180px)}
    .face-back{transform:rotateY(180deg) translateZ(180px)}
    .face-right{transform:rotateY(90deg) translateZ(180px)}
    .face-left{transform:rotateY(-90deg) translateZ(180px)}
    .face-top{transform:rotateX(90deg) translateZ(180px)}
    .face-bottom{transform:rotateX(-90deg) translateZ(180px)}
    .mini-controls{display:flex;gap:8px;align-items:center;margin-top:12px}
    .thumbs{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
    .thumbs img{width:72px;height:72px;object-fit:cover;border-radius:12px;border:3px solid rgba(255,255,255,0.3);cursor:pointer;transition:all 0.3s ease;box-shadow:0 4px 15px rgba(0,0,0,0.2)}
    .thumbs img:hover{transform:scale(1.1);border-color:rgba(255,107,157,0.8)}
    .thumbs img.active{outline:4px solid #feca57;border-color:#ff6b9d;transform:scale(1.08);box-shadow:0 8px 25px rgba(255,107,157,0.6)}
    .right-col{position:sticky;top:28px}
    .status{color:#fff;font-size:13px;margin-top:8px;text-shadow:0 2px 4px rgba(0,0,0,0.3)}
    #particles{position:fixed;left:0;top:0;right:0;bottom:0;pointer-events:none;z-index:0}
    .hint{font-size:13px;color:#fff;text-shadow:0 2px 4px rgba(0,0,0,0.3)}
    @media (max-width:980px){main{grid-template-columns:1fr} .face-front,.cube-face{width:300px;height:300px} .scene{width:300px;height:300px}}
    .pulse{animation:pulse 1.8s infinite}
    @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.02)}100%{transform:scale(1)}}
    input[type="file"], input[type="text"]{background:rgba(255,255,255,0.15);backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.3);color:#fff;border-radius:12px;padding:10px;transition:all 0.3s ease}
    input[type="file"]:hover, input[type="text"]:hover{border-color:rgba(255,255,255,0.5);background:rgba(255,255,255,0.2)}
    input[type="text"]::placeholder{color:rgba(255,255,255,0.6)}
    h2,h3,h4{color:#fff;text-shadow:0 2px 8px rgba(0,0,0,0.3)}
    code{background:rgba(255,255,255,0.2);padding:2px 6px;border-radius:4px;color:#feca57}
  </style>
</head>
<body>
  <canvas id="particles"></canvas>
  <div class="wrap">
    <header>
      <div class="logo">SV</div>
      <div>
        <h1>Study Visualizer — Interactive 3D Cube</h1>
        <p class="lead">Upload a diagram or topic — get six AI-like views, explore with playful controls and export for class use.</p>
      </div>
    </header>

    <main>
      <div>
        <div class="card hero" style="display:flex;align-items:flex-start;gap:12px">
          <div class="left" style="flex:1">
            <h2 style="margin:0">Live demo — create six views</h2>
            <p class="hint">Upload an image and type a short description (e.g., "benzene molecule top view"). This demo will first try the remote n8n service, then fallback locally if remote fails.</p>

            <div style="display:flex;gap:8px;margin-top:12px;align-items:center">
              <input id="file" type="file" accept="image/*" />
              <input id="desc" type="text" placeholder="Enter description or topic" style="flex:1" />
              <button class="btn" id="gen">Generate</button>
            </div>

            <div class="mini-controls">
              <button class="btn-ghost" id="autoplay">Autoplay: Off</button>
              <button class="btn-ghost" id="spin">Spin</button>
              <button class="btn-ghost" id="downloadAll">Download faces</button>
              <div style="flex:1;text-align:right"><span class="status" id="status">No image loaded</span></div>
            </div>

            <div class="thumbs" id="thumbs"></div>
          </div>

          <div style="width:380px;display:flex;flex-direction:column;align-items:center">
            <div class="stage card" id="stage" style="width:380px;height:380px;display:flex;align-items:center;justify-content:center">
              <div class="scene" id="cube" style="transform:rotateX(-12deg) rotateY(20deg)">
                <div class="cube-face face-front"><img id="f-front" src="/" alt="front"/></div>
                <div class="cube-face face-back"><img id="f-back" src="/" alt="back"/></div>
                <div class="cube-face face-right"><img id="f-right" src="/" alt="right"/></div>
                <div class="cube-face face-left"><img id="f-left" src="/" alt="left"/></div>
                <div class="cube-face face-top"><img id="f-top" src="/" alt="top"/></div>
                <div class="cube-face face-bottom"><img id="f-bottom" src="/" alt="bottom"/></div>
              </div>
            </div>

            <div style="display:flex;gap:8px;margin-top:10px;">
              <button class="btn-ghost" id="left">⟲</button>
              <button class="btn-ghost" id="right">⟳</button>
              <button class="btn-ghost" id="up">▲</button>
              <button class="btn-ghost" id="down">▼</button>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:14px">
          <h3 style="margin:0">Interactive tips</h3>
          <ul style="color:#fff;padding-left:18px;margin-top:8px;text-shadow:0 2px 4px rgba(0,0,0,0.3)">
            <li>Drag the cube to rotate it manually.</li>
            <li>Click thumbnails to highlight and focus that face.</li>
            <li>Press <code>Space</code> to toggle autoplay spin.</li>
            <li>Use download to save images for slides.</li>
          </ul>
        </div>
      </div>

      <aside class="right-col">
        <div class="card">
          <h3 style="margin:0">OUR SERVICES</h3>
          <p style="color:#fff;margin-top:8px;text-shadow:0 2px 4px rgba(0,0,0,0.3)">Gives the 3D realistic image of all sides by using ai agent and help students to better visualization of concepts. Input that website take is image and discription of image or topic. Six image that ai agent is going to give is added on output in website like a cube all images are in the form of cube and user can rotate it easily.</p>

          <div style="margin-top:12px">
            <strong>Export</strong>
            <p class="status">After generate: download all faces or right-click any face to save one image.</p>
            <button class="btn" id="shareBtn" style="margin-top:8px">Copy share text</button>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h4 style="margin:0">Examples</h4>
          <p class="status" style="margin-top:8px">Try: "satellite view of volcano", "car engine section", "pyramid cross-section"</p>
        </div>
      </aside>
    </main>
  </div>

  <script>
    // ----------- Config -----------
    const N8N_URL = "https://selectable-doomily-max.ngrok-free.dev/webhook-test/my-webhook";
    // Local uploaded workflow path (provided as requested). Your environment/tooling can transform this into a served URL if needed.
    const UPLOADED_WORKFLOW_PATH = '/mnt/data/final work flow (1).json';
    // ------------------------------

    // Particles background
    const canvas = document.getElementById('particles');
    const ctx = canvas.getContext('2d');
    let W, H, parts=[];
    function resize(){W=canvas.width=innerWidth;H=canvas.height=innerHeight}
    addEventListener('resize',resize);resize();
    const colors=['rgba(255,107,157,0.3)','rgba(254,202,87,0.3)','rgba(72,219,251,0.3)','rgba(255,159,243,0.3)'];
    for(let i=0;i<120;i++) parts.push({x:Math.random()*W,y:Math.random()*H,r:Math.random()*2.5+0.8,vx:(Math.random()-0.5)*0.3,vy:(Math.random()-0.5)*0.3,c:colors[Math.floor(Math.random()*colors.length)]});
    function tick(){ctx.clearRect(0,0,W,H);for(const p of parts){p.x+=p.vx;p.y+=p.vy;if(p.x<0)p.x=W; if(p.x>W)p.x=0; if(p.y<0)p.y=H; if(p.y>H)p.y=0; ctx.beginPath(); ctx.fillStyle=p.c; ctx.shadowBlur=15; ctx.shadowColor=p.c; ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;} requestAnimationFrame(tick);} tick();

    // Elements
    const fileEl = document.getElementById('file');
    const genBtn = document.getElementById('gen');
    const status = document.getElementById('status');
    const descEl = document.getElementById('desc');
    const thumbs = document.getElementById('thumbs');

    let sourceImage = null;
    let latestFaces = []; // stores object URLs; we'll revoke them when replaced

    fileEl.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      sourceImage = await loadImageFromFile(f);
      status.textContent = 'Image loaded. Enter a description and click Generate.';
    });

    // helper to revoke object URLs
    function clearLatestFaces(){
      latestFaces.forEach(u => {
        try{ URL.revokeObjectURL(u); } catch(e){}
      });
      latestFaces = [];
    }

    // ---------- Remote n8n integration + fallback to local simulation ----------
    genBtn.addEventListener('click', async () => {
      if (!fileEl.files || !fileEl.files[0]) { alert('Please upload an image first.'); return; }
      const file = fileEl.files[0];
      const desc = descEl.value || 'No description';

      status.textContent = 'Sending to remote processor...';
      playPop();
      showProgress();

      const fd = new FormData();
      fd.append('image', file);
      fd.append('description', desc);

      try {
        const resp = await fetch(N8N_URL, { method: 'POST', body: fd, mode: 'cors' });

        if (!resp.ok) {
          const txt = await resp.text().catch(()=>'<no body>');
          console.error('n8n returned error', resp.status, resp.statusText, txt);
          alert('Server error: ' + resp.status + ' — see console for details.');
          hideProgress();
          return;
        }

        const ct = (resp.headers.get('content-type') || '').toLowerCase();

        // ========== 1) JSON response ==========
        if (ct.includes('application/json')) {
          const json = await resp.json();

          // Accept many JSON shapes:
          // - { faces: [urlOrDataUrl, ...] }
          // - { images: { front: url, ... } }
          // - { data: [ ... ] } or nested structures containing strings
          if (Array.isArray(json.faces) && json.faces.length === 6) {
            clearLatestFaces();
            latestFaces = json.faces.map(f => normalizeFaceUrl(f));
            applyFacesToCube(latestFaces);
            populateThumbs(latestFaces);
            status.innerHTML = `Generated 6 views for: <strong>${escapeHtml(desc)}</strong> (remote JSON)`;
            hideProgress(); burstConfetti(); return;
          }

          if (json.images && typeof json.images === 'object') {
            const keys = ['front','back','right','left','top','bottom'];
            const arr = keys.map(k => json.images[k] || json.images[k.toUpperCase()] || '');
            if (arr.filter(Boolean).length === 6) {
              clearLatestFaces();
              latestFaces = arr.map(normalizeFaceUrl);
              applyFacesToCube(latestFaces);
              populateThumbs(latestFaces);
              status.innerHTML = `Generated 6 views for: <strong>${escapeHtml(desc)}</strong> (remote JSON images)`;
              hideProgress(); burstConfetti(); return;
            }
          }

          // fallback: collect any data URLs / http urls from JSON until we have 6
          const collected = [];
          (function collect(o){
            if (!o || collected.length >= 6) return;
            if (typeof o === 'string' && (o.startsWith('http') || o.startsWith('data:'))) collected.push(o);
            else if (Array.isArray(o)) o.forEach(collect);
            else if (typeof o === 'object') Object.values(o).forEach(collect);
          })(json);

          if (collected.length >= 6) {
            clearLatestFaces();
            latestFaces = collected.slice(0,6).map(normalizeFaceUrl);
            applyFacesToCube(latestFaces);
            populateThumbs(latestFaces);
            status.innerHTML = `Generated 6 views for: <strong>${escapeHtml(desc)}</strong> (remote JSON - auto-collected)`;
            hideProgress(); burstConfetti(); return;
          }

          // else fallthrough to error
          throw new Error('JSON returned but no usable faces found');
        }

        // ========== 2) MULTIPART BINARY (expected: face0..face5) ==========
        if (ct.includes('multipart/')) {
          // Extract boundary token
          const bMatch = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
          const boundary = bMatch ? (bMatch[1] || bMatch[2]) : null;
          if (!boundary) throw new Error('Multipart response but no boundary found');

          const buffer = await resp.arrayBuffer();
          // convert to string for boundary splitting (assumes server used base64 for binary parts,
          // otherwise raw binary to text can corrupt bytes; most server multipart responses encode binary parts as base64)
          const text = new TextDecoder('utf-8').decode(buffer);
          const parts = text.split(new RegExp(`--${boundary}`)).map(s => s.trim()).filter(s => s && s !== '--');

          const faces = [];
          for (const part of parts) {
            // header / body split
            const idx = part.indexOf('\r\n\r\n');
            if (idx < 0) continue;
            const headersRaw = part.slice(0, idx).trim();
            let bodyRaw = part.slice(idx + 4).trim();

            // Try to extract name from Content-Disposition
            const nameMatch = headersRaw.match(/content-disposition:[^\r\n]*name="?([^"\r\n;]+)"?/i);
            const partName = nameMatch ? nameMatch[1] : null;

            // Determine mime from Content-Type header if present
            const mimeMatch = headersRaw.match(/content-type:\s*([^\r\n;]+)/i);
            const mime = mimeMatch ? mimeMatch[1].trim() : 'image/jpeg';

            // If the part indicates base64 encoding, decode it
            const isBase64 = /content-transfer-encoding:\s*base64/i.test(headersRaw);

            if (isBase64) {
              // Clean body (remove possible trailing boundary markers)
              bodyRaw = bodyRaw.replace(/--$/, '').trim();
              // In case the part has extra line breaks, join them
              const base64 = bodyRaw.replace(/\r\n/g, '').replace(/\n/g, '');
              try {
                const binary = atob(base64);
                const len = binary.length;
                const bytes = new Uint8Array(len);
                for (let i=0;i<len;i++) bytes[i] = binary.charCodeAt(i);
                const blob = new Blob([bytes], { type: mime });
                const url = URL.createObjectURL(blob);
                // Only accept parts named face0..face5 (or accept any and take first six in order)
                if (partName && /^face[0-5]$/.test(partName.toLowerCase())) {
                  faces[parseInt(partName.slice(4),10)] = url;
                } else {
                  faces.push(url);
                }
              } catch(e) {
                console.warn('Failed to decode base64 multipart part', e);
              }
            } else {
              // Not base64 — this is tricky because decoding raw binary to text corrupts bytes.
              // Best-effort: check if bodyRaw is a data-url or a URL string
              if (bodyRaw.startsWith('data:')) {
                faces.push(bodyRaw);
              } else if (bodyRaw.startsWith('http')) {
                faces.push(bodyRaw);
              } else {
                // cannot reliably reconstruct raw binary from text conversion — log and skip
                console.warn('Multipart part appears non-base64 and not a data/http url — skipping', headersRaw);
              }
            }
          }

          // Ensure faces array length = 6 (fill missing with null)
          const final = [];
          for (let i=0;i<6;i++) final[i] = (faces[i]||faces.shift()||null);

          if (final.filter(Boolean).length === 6) {
            clearLatestFaces();
            latestFaces = final.map(normalizeFaceUrl);
            applyFacesToCube(latestFaces);
            populateThumbs(latestFaces);
            status.innerHTML = `Generated 6 binary faces from n8n (multipart)`;
            hideProgress(); burstConfetti(); return;
          } else {
            console.warn('Multipart parsing produced', final);
            // If not full set, fallthrough to other cases / error out
          }
        }

        // ========== 3) SINGLE IMAGE BINARY (server returned one image blob) ==========
        if (ct.startsWith('image/')) {
          // server returned single image. We will NOT duplicate automatically.
          // Instead, create object url and show a warning so user knows server should return 6 parts.
          const blob = await resp.blob();
          const url = URL.createObjectURL(blob);
          clearLatestFaces();
          latestFaces = [url];
          applyFacesToCube(latestFaces);
          populateThumbs(latestFaces);
          status.innerHTML = `Server returned ONE binary image — please return six images (face0..face5) for full cube.`;
          hideProgress();
          return;
        }

        // ========== 4) fallback: entire body text contains JSON-like or URLs ==========
        {
          const txt = await resp.text().catch(()=>null);
          if (txt) {
            try {
              const maybe = JSON.parse(txt);
              // recursive handling by reusing the JSON branch
              if (maybe) {
                // reuse JSON handling via temporary function call (simple)
                const collected = [];
                (function collect(o){
                  if (!o || collected.length >= 6) return;
                  if (typeof o === 'string' && (o.startsWith('http') || o.startsWith('data:'))) collected.push(o);
                  else if (Array.isArray(o)) o.forEach(collect);
                  else if (typeof o === 'object') Object.values(o).forEach(collect);
                })(maybe);
                if (collected.length >= 6) {
                  clearLatestFaces();
                  latestFaces = collected.slice(0,6).map(normalizeFaceUrl);
                  applyFacesToCube(latestFaces);
                  populateThumbs(latestFaces);
                  status.innerHTML = `Generated 6 views for: <strong>${escapeHtml(desc)}</strong> (remote fallback)`;
                  hideProgress(); burstConfetti(); return;
                }
              }
            } catch(e) {
              // not json — continue
            }
          }
        }

        throw new Error('Unsupported response format from n8n. Check that your workflow returns either JSON {faces:[...]} or multipart binary with face0..face5 parts (base64).');

      } catch (err) {
        console.warn('Remote processing failed or returned unsupported format — falling back to local simulation.', err);
        // fallback to local simulation (six generated variations)
        try {
          const ops = [
            {flip:false,rot:0,gray:false,scale:1},
            {flip:true,rot:0,gray:false,scale:1},
            {flip:false,rot:90,gray:false,scale:1},
            {flip:false,rot:-90,gray:true,scale:1},
            {flip:false,rot:0,gray:false,scale:1.05,blur:2},
            {flip:false,rot:0,gray:true,scale:0.9}
          ];
          const results = await Promise.all(ops.map(o => canvasTransform(sourceImage,o)));
          clearLatestFaces();
          latestFaces = results;
          applyFacesToCube(results);
          populateThumbs(results);
          status.innerHTML = `Generated 6 local views for: <strong>${escapeHtml(desc)}</strong> (local fallback)`;
          hideProgress();
          burstConfetti();
        } catch (localErr) {
          hideProgress();
          alert('Both remote and local generation failed. See console for details.');
          console.error(localErr);
        }
      }
    });

    // image -> cube functions
    function applyFacesToCube(arr){
      const keys = ['front','back','right','left','top','bottom'];
      keys.forEach((k,i)=>{
        const el=document.getElementById('f-'+k);
        if(el) el.src = arr[i] || '/';
      });
    }
    function populateThumbs(arr){
      thumbs.innerHTML = '';
      arr.forEach((d,i)=>{
        const im=document.createElement('img');
        im.src=d || '';
        im.title=['Front','Back','Right','Left','Top','Bottom'][i];
        im.addEventListener('click', ()=>{ focusFace(i); setActiveThumb(i); });
        if(i===0) im.classList.add('active');
        thumbs.appendChild(im);
      });
    }
    function setActiveThumb(i){ Array.from(thumbs.children).forEach((t,idx)=> t.classList.toggle('active', idx===i)); }

    // progress overlay
    let progEl=null;
    function showProgress(){ if(progEl) return; progEl=document.createElement('div'); progEl.style.position='fixed'; progEl.style.left='50%'; progEl.style.top='12%'; progEl.style.transform='translateX(-50%)'; progEl.style.padding='14px 20px'; progEl.style.background='linear-gradient(135deg,rgba(255,107,157,0.9),rgba(254,202,87,0.9))'; progEl.style.border='2px solid rgba(255,255,255,0.3)'; progEl.style.borderRadius='16px'; progEl.style.color='#fff'; progEl.style.fontWeight='700'; progEl.style.boxShadow='0 8px 32px rgba(0,0,0,0.4)'; progEl.style.backdropFilter='blur(10px)'; progEl.innerText='Processing — thinking like an AI agent...'; document.body.appendChild(progEl); }
    function hideProgress(){ if(!progEl) return; progEl.remove(); progEl=null; }

    // focus cube and rotation handlers
    const cube = document.getElementById('cube'); let rx=-12, ry=20;
    function focusFace(i){ if(i===0) { rx=-12; ry=20; } if(i===1) { rx=-12; ry=200; } if(i===2) { rx=-12; ry=110; } if(i===3) { rx=-12; ry=-70; } if(i===4) { rx=-100; ry=20; } if(i===5) { rx=80; ry=20; } cube.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`; }

    // canvas transform (local generator)
    function canvasTransform(img, opts={}){ return new Promise((res)=>{ const size = 900; const c = document.createElement('canvas'); c.width=size; c.height=size; const ctx = c.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,size,size); ctx.save(); ctx.translate(size/2,size/2); if(opts.rot) ctx.rotate(opts.rot*Math.PI/180); if(opts.flip) ctx.scale(-1,1); const drawW = size * (opts.scale||1); const drawH = size * (opts.scale||1); ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH); ctx.restore(); if(opts.gray||opts.blur){ const tmp=document.createElement('canvas'); tmp.width=size; tmp.height=size; const t=tmp.getContext('2d'); t.drawImage(c,0,0); if(opts.gray){ let id=t.getImageData(0,0,size,size); for(let i=0;i<id.data.length;i+=4){ const r=id.data[i],g=id.data[i+1],b=id.data[i+2]; const v=0.21*r+0.72*g+0.07*b; id.data[i]=id.data[i+1]=id.data[i+2]=v; } t.putImageData(id,0,0);} if(opts.blur){ t.globalAlpha=0.6; for(let i=0;i< (opts.blur||1); i++){ t.drawImage(tmp,-1,0); t.drawImage(tmp,1,0); t.drawImage(tmp,0,-1); t.drawImage(tmp,0,1);} t.globalAlpha=1;} const out=document.createElement('canvas'); out.width=360; out.height=360; out.getContext('2d').drawImage(tmp,0,0,360,360); res(out.toDataURL('image/jpeg',0.92)); } else { const out=document.createElement('canvas'); out.width=360; out.height=360; out.getContext('2d').drawImage(c,0,0,360,360); res(out.toDataURL('image/jpeg',0.92)); } }) }

    function loadImageFromFile(file){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=URL.createObjectURL(file); }) }
    function escapeHtml(s){ return String(s||'').replace(/[&<>\"']/g, function(c){ return {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":"&#39;"}[c]; }); }

    // Drag rotation
    (function(){ let dragging=false,lastX=0,lastY=0; document.getElementById('stage').addEventListener('pointerdown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId); }); window.addEventListener('pointerup', ()=>dragging=false); window.addEventListener('pointermove', e=>{ if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; ry+=dx*0.4; rx-=dy*0.4; cube.style.transform=`rotateX(${rx}deg) rotateY(${ry}deg)`; }); })();

    // audio and confetti
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playPop(){ try{ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.value=600; g.gain.value=0.02; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.frequency.value=350; },80); setTimeout(()=>{ o.stop(); },180);}catch(e){} }
    function burstConfetti(){ for(let i=0;i<36;i++){ const el=document.createElement('div'); el.style.position='fixed'; el.style.left=(50+Math.random()*20-10)+'%'; el.style.top='20%'; el.style.width='10px'; el.style.height='14px'; el.style.background=['#ff6b9d','#feca57','#48dbfb','#ff9ff3','#fff'][Math.floor(Math.random()*5)]; el.style.opacity=0.95; el.style.transform='translateY(0) rotate('+Math.random()*180+'deg)'; el.style.borderRadius='3px'; el.style.zIndex=9999; el.style.boxShadow='0 0 10px currentColor'; document.body.appendChild(el); const dx=(Math.random()-0.5)*250; const dy=500+Math.random()*250; el.animate([{transform:`translate(${dx}px,${dy}px) rotate(${Math.random()*360}deg)`,opacity:0.95},{transform:`translate(${dx}px,${dy+80}px) rotate(${Math.random()*720}deg)`,opacity:0}],{duration:1800+Math.random()*600,easing:'cubic-bezier(.2,.9,.2,1)'}).onfinish = ()=>el.remove(); } }

    // keyboard toggle for autoplay
    document.addEventListener('keydown', e=>{ if(e.code==='Space'){ toggleAuto(); e.preventDefault(); } });

    // autoplay spin
    let auto = false, spinAnim=null;
    const autoplayBtn = document.getElementById('autoplay');
    autoplayBtn.addEventListener('click', toggleAuto);
    function toggleAuto(){ auto=!auto; autoplayBtn.textContent = 'Autoplay: '+(auto?'On':'Off'); if(auto) startSpin(); else stopSpin(); }
    function startSpin(){ stopSpin(); spinAnim = setInterval(()=>{ ry+=2; cube.style.transform=`rotateX(${rx}deg) rotateY(${ry}deg)`; },20); }
    function stopSpin(){ if(spinAnim) clearInterval(spinAnim); spinAnim=null; }

    // quick spin button
    document.getElementById('spin').addEventListener('click', ()=>{ let i=0; const id=setInterval(()=>{ ry+=20; cube.style.transform=`rotateX(${rx}deg) rotateY(${ry}deg)`; i++; if(i>8) clearInterval(id); },60); });

    // download all faces
    document.getElementById('downloadAll').addEventListener('click', async ()=>{
      if(!latestFaces.length){ alert('No images to download.'); return; }
      latestFaces.forEach((d,i)=>{ const a=document.createElement('a'); a.href=d; a.download='face-'+i+'.jpg'; document.body.appendChild(a); a.click(); a.remove(); });
    });

    function normalizeFaceUrl(face){
      if(!face) return '';
      // If it's already a data: or http link, return as-is
      const s = String(face);
      if (s.startsWith('data:') || s.startsWith('http')) return s;
      // If it's a Drive link, convert to embeddable uc URL
      if (s.includes('drive.google.com')) {
        const m = s.match(/\/d\/([a-zA-Z0-9_-]+)/) || s.match(/[?&]id=([a-zA-Z0-9_-]+)/);
        if (m && m[1]) return `https://drive.google.com/uc?export=view&id=${m[1]}`;
      }
      return s;
    }

    // share copy text
    document.getElementById('shareBtn').addEventListener('click', ()=>{ const text = `Study Visualizer — generated views for: ${descEl.value||'untitled'}`; navigator.clipboard.writeText(text).then(()=>{ alert('Share text copied to clipboard'); }); });

    // seed placeholder
    (async function seed(){ const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='900' height='900'><rect width='100%' height='100%' fill='white'/><g><text x='50%' y='48%' font-size='40' text-anchor='middle' fill='#444'>Upload your diagram</text><text x='50%' y='58%' font-size='20' text-anchor='middle' fill='#666'>Then press Generate</text></g></svg>`; const url = 'data:image/svg+xml;utf8,'+encodeURIComponent(svg); sourceImage = await loadImageFromUrl(url); })();

    function loadImageFromUrl(url){ return new Promise((res,rej)=>{ const img=new Image(); img.crossOrigin='anonymous'; img.onload=()=>res(img); img.onerror=rej; img.src=url; }) }
  </script>
</body>
</html>
